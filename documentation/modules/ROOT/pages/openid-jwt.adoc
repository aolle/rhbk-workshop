= OpenID + JWT
include::_attributes.adoc[]

This tutorial shows how to implement an OpenID Connect flow with a JWT implementation.

We will configure a new Red Hat Build for Keycloak (RHBK) realm and configure it. After that, we will still deploy the stack and configure the user's access to allow roles for different operations. 

[#architecture]
== Architecture
Firstly, we need a RHBK instance. This instance controls the access across our applications. An advantage of OpenID Connect with JWT implementation is the easy way to connect different applications and frameworks, as each has libraries to facilitate that. 

In this case, we'll develop a complete architecture with some microservices. We have one frontend, developed in ReactJS, which shows the data.

The user backend microservice uses Quarkus, and we can see an easy integration between Keycloak and the application, thanks to its OpenID library. 

image::openid/frontend-architecture-01.png[]

[#rhbk]
== RHBK configuration
This section explains how to create a new realm with OpenID connect flow and how to configure it. 

=== Create a realm

A realm is a domain in RHBK where we can configure clients, users, roles, etc. In this example, we provide an import with the configuration to run this workshop.

However, we're creating one to see all the processes:

image::openid/rhbk-create-realm-01.png[]

=== Create a client

A client is a RHBK consumer. We're using an OpenID Connect flow, so depending on whether we are configuring a private or public client, we must select a standard or implicit flow. 

To register a new client, go to the Keycloak console admin into the client options. In this section, find the option called "Create client". 

image::openid/rhbk-create-client-01.png[]

The following step depends on the flow that we can. In this workshop, we will use the standard flow for backend applications and the implicit flow for the frontend application.

image::openid/rhbk-create-client-02.png[]

The last step indicates a few security configuration parameters such as web origins, redirect URL after a correct login, etc.

image::openid/rhbk-create-client-03.png[]

[#backend]
== Backend

Now, we will configure and secure a backend service. In this case, we are using Quarkus to develop the application.

The application is a backend service to store a list of users of a sports centre.  

=== Find the backend URL
The front-end application consumes a back-end application. We need to know this URL:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
oc get route -A | grep ms-users | awk '{print $3}'
----

=== RHBK configuration

The Keycloak instance contains a configured realm with a specific client for this workshop. 

This application is a backend service that uses a standard flow with a private client. In the following section, you can see all the configurations needed.

If you wish to see the OpenID Connect client configuration and explore the RHBK admin console, you can navigate along the following section.

image::openid/backend-rhbk-config-01.png[]

=== Quarkus configuration

Quarkus simplifies the security configuration in our backend services. 

We need to import the corresponding library. In this case, we're working with RHBK, but indeed, it's an OpenID connect protocol, so we'll use the ```quarkus-oidc``` generic library.

[.lines_space]
[.console-input]
[source,xml, subs="+macros,+attributes"]
----
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-oidc</artifactId>
    </dependency>
----

At this point, we only have to configure some properties to indicate where and how to use the OIDC server:

[.lines_space]
[.console-input]
[source,properties, subs="+macros,+attributes"]
----
quarkus.oidc.auth-server-url=http://localhost:8080/realms/jwt-demo
quarkus.oidc.client-id=padel-user-backend
quarkus.oidc.credentials.secret=0unvbdWCBWcFMQUyVukqA6TQuHHWjj9x
----

[WARNING,subs="attributes+,+macros"]
====
The client secret is the password that uses the client application. It's critical to provision it securely.
====

Now, we can secure our backend application endpoints. 

=== Secure the application

Another advantage of using Quarkus is the facility of use. We can secure the application endpoint just with annotations. 

To secure the applications, we have two options: generic or in a fine-grain way. The main difference between both is to indicate the user roles using ```@RolesAllowed({  })``` or not with ```@Authenticated``` in the application controllers.

The client's authentication, authorization and roles are managed automatically by Quarkus. 

=== CRUD operations

CRUD represents all the basic REST operations you can do over a domain: create, read, update and delete. 

Depending on the operation, we need more security or not. In this case, we will see the securitization for the main options. 

==== How to get an access token

We will use the curl bash client to test the rest of the application endpoints. If you prefer something more visual, you can avoid doing this section and jump directly to the front-end application section. 

To get an access token, we need to configure some parameters that RHBK ask for. 

[NOTE,subs="bash,+macros"]
====
[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
KCHOST=http://localhost:8080                               
REALM=jwt-demo                                   
CLIENT_ID=padel-user-backend
CLIENT_SECRET=0unvbdWCBWcFMQUyVukqA6TQuHHWjj9x
UNAME=dborrego                                                 
PASSWORD=dborrego
----
====

In each petition, you have to put the access token. You can request for one the following way: 

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
ACCESS_TOKEN=`curl \
  -d "client_id=$CLIENT_ID" \
  -d "client_secret=$CLIENT_SECRET" \
  -d "username=$UNAME" \
  -d "password=$PASSWORD" \
  -d "grant_type=password" \
  "$KCHOST/realms/$REALM/protocol/openid-connect/token"  | jq -r '.access_token'`
----

==== Create

Creating a new element into the domain is a restricted operation that just should be done by an admin. We have a specific role for admins: ```padel-users-admin```

The application has to avoid the connection and return 403 to any user without enough permission:

[.lines_space]
[.console-input]
[source,java, subs="+macros,+attributes"]
----
  @POST
  @RolesAllowed({ "padel-users-admin" })
  public Uni<User> create(User user) {
    return Panache.withTransaction(user::persist);
  }
----

To test the creation of a user, you can use the following command: 

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
curl \
  -X POST \
  -H 'Authorization: Bearer '$ACCESS_TOKEN \
  -H 'Content-Type: application/json' \
  --data '{"name":"David", "year": 1988, "level": 3.12, "username":"dborrego"}' \
  localhost:8081/users
{"id":1,"username":"dborrego","name":"David","year":1988,"level":3.12}
----

==== Find

We allow any user to find himself, so we need some filters. 

The first control we need is to check if the user is logged in with the correct role to enter the application. 

The second one is that the application checks it's just trying to get its user. Nobody can retrieve another user who is not himself. A good example is a bank application where you can get your account information, but not another one. 

The last check involves getting information from the token and taking it to the database query. 

[.lines_space]
[.console-input]
[source,java, subs="+macros,+attributes"]
----
  @GET
  @Path("/{id}")
  @RolesAllowed({ "padel-users-player" })
  public Uni<User> ListById(Long id) {
    final String username = securityIdentity.getPrincipal().getName();
    Log.info(String.format("User %s find user with id %d", username, id));
    return User.<User>findById(id)
        .onItem()
        .ifNotNull()
        .transform(user -> {
          if (!username.equals(user.username)) {
            throw new WebApplicationException("El nombre del usuario no coincide", Response.Status.FORBIDDEN);
          }
          return user;
        });
  }
----

Now, you can try to get your user:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
curl \
  -H 'Authorization: Bearer '$ACCESS_TOKEN \
  localhost:8081/users/1
{"id":1,"username":"dborrego","name":"David","year":1988,"level":3.12}
----

[#frontend]
== Frontend

In this section, we want to create a new record in our system, but we must configure some security points. 

=== Find the front-end application URL

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
oc get route -A | grep frontend | awk '{print $3}'
----

When you enter into the application, you should see a message like this:

image::openid/frontend-02.png[]

This message indicates that you have not logged into the application. So we have to log in. We need a user with enough roles to enter into the platform. 

=== Create the user

The first step for us is to create a new user to show all the configuration step by step.

So, enter the RHBK admin console, go to the "users" section and press the "add user" button.

image::openid/frontend-create-user-01.png[]

In the following screen, we can select different properties about our new user. We are just going to set the name.

image::openid/frontend-create-user-02.png[]

Once the user is created, we have to set a 
temporal or definitive credential to enter. 

To do it, we go to the "Credentials" tab and press the "Set password" button.

[NOTE,subs="attributes+,+macros"]
====
For this example, you can use whatever password you want, but I recommend using an easy password as "reader". 
====

image::openid/frontend-create-user-03.png[]

=== Login into the frontend application

Now, we have our new user, so we can return to the frontend URL and try to log in to the application.

Click the green button and the application will redirect you to the Keycloak login page.

image::openid/frontend-login-01.png[]

Once you log in, you will be redirected to the main page, already signed in.

Now you should see the following button: 

image::openid/frontend-login-02.png[]

It means you are correctly logged in to the application. You can't see anything thanks to the ReactJS configuration. 

=== ReactJS configuration

[IMPORTANT,subs="attributes+,+macros"]
====
This section shows Javascript code to show how easy it is to configure a ReactJS application. 

Keycloak gives us a library to integrate into any popular frontend framework to work easily. In this case, I've used ```"keycloak-js": "^22.0.1",```
====

We can see the code and inspect it. The variables ```isAdmin``` and ```isUser``` control the roles of the users. 

The Menu component renders the application menu depending on the roles. So, if the user is an admin, it'll be able to see the "users" option, and if it is a player, it can see the matches tab. 

[.lines_space]
[.console-input]
[source,javascript, subs="+macros,+attributes"]
----
  const isAdmin = roles.includes('padel-users-admin');
  const isUser = roles.includes('padel-player'); 

  if (isAdmin || isUser) {
    return (
      <Menu borderless>
        {isAdmin && (
          <Menu.Item as={Link} to="/users">
            <Button color="blue" size="small">
              <Icon name="users" /> Usuarios
            </Button>
          </Menu.Item>
        )}
        {isUser && (
          <Menu.Item as={Link} to="/matches">
            <Button color="blue" size="small">
              <Icon name="soccer" /> Partidos
            </Button>
          </Menu.Item>
        )}
      </Menu>
    );
  } else {
    return null; 
  }
----

As we're working with the SPA page, the user may know the path to access, for example, the admin user's page. The Keycloak library controls this option too: 

image::openid/frontend-login-03.png[]

=== Add roles to the user

At this point, we know how the ReactJS security model depends on the user roles in the JWT token. 

Now, we're going to add roles to the users to be able to do private actions. 

The first step is to return to the RHBK admin page and find the user ```reader```.

Once we have located the user, we find the "Role mapping" tab. 

image::openid/frontend-add-role-01.png[]

After clicking the "Assign role" button, RHBK shows a list of all available roles in the system.

Select the role "padel-player" and click the "Assign" button.

image::openid/frontend-add-role-02.png[]

Now, you can return to the front page. It's mandatory to log out and log in to refresh the JWT token. 

After doing it, your user has the role assigned, and the front shows him the "Matches" tab.

image::openid/frontend-add-role-03.png[]

=== Add role admin to manage users

Now, you should repeat the process to add a role to the user ```reader```. Currently, we assign the role ```padel-users-admin``` to the user. After that, you should be able to see the main page like this: 

image::openid/frontend-add-role-admin-01.png[]

=== Call the backend service

Now, we know how to manage the security in both applications following the OpenID and JWT approach. 

We need the last point: join the two applications. 

We have to propagate the JWT user token to the back-end application. It gets the token, and depending on the role, it allows doing the operation or not. 

[.lines_space]
[.console-input]
[source,javascript, subs="+macros,+attributes"]
----
export const createUser = async (domain, userToken, userData) => {
    const response = await fetch(`${BASE_URL}${domain}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${userToken}`  
        },
        body: JSON.stringify(userData)
    });

    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
};
----