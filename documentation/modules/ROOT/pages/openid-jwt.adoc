= OpenID + JWT
include::_attributes.adoc[]

This tutorial shows how to implement an OpenID Connect flow with a JWT implementation.

We will configure a new Red Hat Build for Keycloak (RHBK) realm and configure it. After that, we will still deploy the stack and configure the user's access to allow roles for different operations. 

[#architecture]
== Architecture
Firstly, we need a RHBK instance. This instance controls the access across our applications. An advantage of OpenID Connect with JWT implementation is the easy way to connect different applications and frameworks, as each has libraries to facilitate that. 

In this case, we'll develop a complete architecture with some microservices. We have one frontend, developed in ReactJS, which shows the data.

The user backend microservice uses Quarkus, and we can see an easy integration between Keycloak and the application, thanks to its OpenID library. 

image::openid/frontend-architecture-01.png[]

[#rhbk]
== RHBK configuration
This section explains how to create a new realm with OpenID connect flow and how to configure it. 

=== Create a realm

A realm is a domain in RHBK where we can configure clients, users, roles, etc. In this example, we provide an import with the configuration to run this workshop.

However, we're creating one to see all the processes:

image::openid/rhbk-create-realm-01.png[]

=== Create a client

A client is a RHBK consumer. We're using an OpenID Connect flow, but we can find some different types depending if we're using a private client or a public client. 

To register a new client, we have to surf the Keycloak console admin into the client options. In this section, we find an option called "Create client". 

image::openid/rhbk-create-client-01.png[]

The following step depends on the flow that we can. In this workshop, we're going to use the standard flow for backend applications and the Implicit flow for the frontend application.

image::openid/rhbk-create-client-02.png[]

The last step indicates some security configuration parameters such as web origins, redirect URL after correct login, etc.

image::openid/rhbk-create-client-03.png[]

[#backend]
== Backend

In this section, we'll see how to configure and secure a backend service. In this case, we're using Quarkus to develop the application.

The application is a backend service to store a list of users of a sports center.  

=== Find the backend URL

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
oc get route -A | grep ms-users | awk '{print $3}'
----

This URL belongs to the backend service and it'll be the point which the frontend service consumes. 

=== RHBK configuration

The Keycloak instance contains a realm configured, with a specific client for this workshop. 

This application is a backend service that uses a standard flow with a private client. In the following section, you can see all the configurations needed by the application.

If you want to see the OpenID Connect client configuration and explore the RHBK admin console, you can surf the following section.

image::openid/backend-rhbk-config-01.png[]

=== Quarkus configuration

Quarkus simplifies the security configuration in our backend services. 

We just need to import the corresponding library, in this case, we're working with RHBK but indeed, it's an OpenID connect protocol, so we'll use the ```quarkus-oidc``` library.

[.lines_space]
[.console-input]
[source,xml, subs="+macros,+attributes"]
----
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-oidc</artifactId>
    </dependency>
----

At this point, we only have to configure some properties to indicate where and how to use the OIDC server:

[.lines_space]
[.console-input]
[source,properties, subs="+macros,+attributes"]
----
quarkus.oidc.auth-server-url=http://localhost:8080/realms/jwt-demo
quarkus.oidc.client-id=padel-user-backend
quarkus.oidc.credentials.secret=0unvbdWCBWcFMQUyVukqA6TQuHHWjj9x
----

[WARNING,subs="attributes+,+macros"]
====
The client secret is the password that uses our application, it's very important to provision it securely. 
====

Now, we can secure our backend application endpoints. 

=== Secure the application

Another advantage of using Quarkus is the facility of use. We can secure the application endpoint just with annotations. 

To secure the applications in a thick or fine grain, the main difference is to indicate the user roles using ```@RolesAllowed({  })``` or not with ```@Authenticated``` in the controllers.

The authentication, authorization and roles of the client, are managed automatically by Quarkus. 

=== CRUD operations

CRUD represents all the basic REST operations that you can do over a domain: create, read, update and delete. 

Depending on the operation, we need more security or not. In this case, we will see the securitization for the main options. 

==== How to get an access token

In this workshop, we'll use the curl bash client to test the rest applications. If you prefer something more visual, you can avoid doing this request, read this part and jump to the frontend section. 

[NOTE,subs="bash,+macros"]
====
In this workshop, we'll use the curl bash client to test the rest applications. If you prefer something more visual, you can avoid doing this request, read this part and jump to the frontend section. 
[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
KCHOST=http://localhost:8080                               
REALM=jwt-demo                                   
CLIENT_ID=padel-user-backend
CLIENT_SECRET=0unvbdWCBWcFMQUyVukqA6TQuHHWjj9x
UNAME=dborrego                                                 
PASSWORD=dborrego
----
====

In each petition, you have to put the access token, you can ask for one the following way: 

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
ACCESS_TOKEN=`curl \
  -d "client_id=$CLIENT_ID" \
  -d "client_secret=$CLIENT_SECRET" \
  -d "username=$UNAME" \
  -d "password=$PASSWORD" \
  -d "grant_type=password" \
  "$KCHOST/realms/$REALM/protocol/openid-connect/token"  | jq -r '.access_token'`
----

==== Create

The operation of creating a new element into the domain is a restricted operation that only should be done by an admin. So we have a special role for admins, this role is ```padel-users-admin```

To avoid the connection and return 403 to any user without permission, our code looks like this:

[.lines_space]
[.console-input]
[source,java, subs="+macros,+attributes"]
----
  @POST
  @RolesAllowed({ "padel-users-admin" })
  public Uni<User> create(User user) {
    return Panache.withTransaction(user::persist);
  }
----

To test the creation of a user, you can use the following command: 

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
curl \
  -X POST \
  -H 'Authorization: Bearer '$ACCESS_TOKEN \
  -H 'Content-Type: application/json' \
  --data '{"name":"David", "year": 1988, "level": 3.12, "username":"dborrego"}' \
  localhost:8081/users
{"id":1,"username":"dborrego","name":"David","year":1988,"level":3.12}
----

==== Find

In this example, we allow any user to find his user, so we need some filters. 

The first, control we need, is to check if the user is logged in with the correct role to enter the application. 

The second one is that the user, once the application checks that it can read users, needs to check that it's just getting his user, it can't retrieve another one. A good example of that is a bank application, you can retrieve your account information, but not another one. 

The last check involves getting some information from the token and taking it to the database query. 

[.lines_space]
[.console-input]
[source,java, subs="+macros,+attributes"]
----
  @GET
  @Path("/{id}")
  @RolesAllowed({ "padel-users-player" })
  public Uni<User> ListById(Long id) {
    final String username = securityIdentity.getPrincipal().getName();
    Log.info(String.format("User %s find user with id %d", username, id));
    return User.<User>findById(id)
        .onItem()
        .ifNotNull()
        .transform(user -> {
          if (!username.equals(user.username)) {
            throw new WebApplicationException("El nombre del usuario no coincide", Response.Status.FORBIDDEN);
          }
          return user;
        });
  }
----

Now, you can try to get your user:

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
curl \
  -H 'Authorization: Bearer '$ACCESS_TOKEN \
  localhost:8081/users/1
{"id":1,"username":"dborrego","name":"David","year":1988,"level":3.12}
----

[#frontend]
== Frontend

In this section, we want to create a new record in our system, but we must configure some security points. 

=== Find the frontend URL

[.lines_space]
[.console-input]
[source,bash, subs="+macros,+attributes"]
----
oc get route -A | grep frontend | awk '{print $3}'
----

When you enter into the application, you should see a message like this:

image::openid/frontend-02.png[]

This message indicates that you have not logged into the application. So we have to log in. We need a user with enough roles to enter into the platform. 

=== Create the user

The first step for us is to create a new user to show all the configuration step by step.

So, enter the RHBK admin console, go to the "users" section and press the "add user" button.

image::openid/frontend-create-user-01.png[]

In the following screen, we can select different properties about our new user. We are just going to set the name.

image::openid/frontend-create-user-02.png[]

Once the user is created, we have to set a 
temporal or definitive credential to enter. 

To do it, we go to the "Credentials" tab and press the "Set password" button.

[NOTE,subs="attributes+,+macros"]
====
For this example, you can use whatever password you want, but I recommend using an easy password as "reader". 
====

image::openid/frontend-create-user-03.png[]

=== Login into the frontend application

Now, we have our new user, so we can return to the frontend URL and try to log in to the application.

If we click the green button, the application redirects us to the Keycloak login page.

image::openid/frontend-login-01.png[]

Use your login credentials, and you'll be taken to the front page, but you'll already be signed in.

Now you should see the following button: 

image::openid/frontend-login-02.png[]

It means you're correctly logged in to the application, but you can't see anything for the ReactJS configuration. 

=== ReactJS configuration

[IMPORTANT,subs="attributes+,+macros"]
====
This section shows Javascript code just to show how easy it is to configure a ReactJS application. 

Keycloak gives us a library to integrate into any most popular frontend frameworks to work easily, in this case, I've used ```"keycloak-js": "^22.0.1",```
====

We can see the code and inspect it. The variables ```isAdmin``` and ```isUser``` control the roles of the users. 

The Menu component renders the application menu depending on the roles. So, if the user is an admin, it'll be able to see the "users" option, and if it is a player, it can see the matches tab. 

[.lines_space]
[.console-input]
[source,javascript, subs="+macros,+attributes"]
----
  const isAdmin = roles.includes('padel-users-admin');
  const isUser = roles.includes('padel-player'); 

  if (isAdmin || isUser) {
    return (
      <Menu borderless>
        {isAdmin && (
          <Menu.Item as={Link} to="/users">
            <Button color="blue" size="small">
              <Icon name="users" /> Usuarios
            </Button>
          </Menu.Item>
        )}
        {isUser && (
          <Menu.Item as={Link} to="/matches">
            <Button color="blue" size="small">
              <Icon name="soccer" /> Partidos
            </Button>
          </Menu.Item>
        )}
      </Menu>
    );
  } else {
    return null; 
  }
----

As we're working with the SPA page, the user may know the path to access, for example, the admin user's page. The Keycloak library controls this option too: 

image::openid/frontend-login-03.png[]

=== Add roles to the user

At this point, we know how the ReactJS security model depends on the user roles in the JWT token. 

Now, we're going to add roles to the users to be able to do private actions. 

The first step is to return to the RHBK admin page and find the user ```reader```.

Once we have located the user, we find the tab "Role mapping". 

image::openid/frontend-add-role-01.png[]

After clicking the button, "Assign role", RHBK shows a list of all available roles in the system.

Select the role "padel-player" and click the "Assign" button.

image::openid/frontend-add-role-02.png[]

Now, you can return to the front page. It's mandatory to log out and log in to refresh the JWT token. 

After doing it, your user has the role assigned, and the front shows him the "Matches" tab.

image::openid/frontend-add-role-03.png[]

=== Add role admin to manage users

Now, at this you should repeat the process to add a role to the user ```reader``` but, now: we're going to assign to him the role ```padel-users-admin```. After that, you should be able to see the main page like this: 

image::openid/frontend-add-role-admin-01.png[]

=== Call the backend service

At this point, we know how to manage the security in backend and frontend applications following the OpenID and JWT approach. 

We just need the last point: join the two applications. 

To do that, we have to propagate the JWT user token to the backend. The backend gets it and depending on the role allows doing the operation or not. 

[.lines_space]
[.console-input]
[source,javascript, subs="+macros,+attributes"]
----
export const createUser = async (domain, userToken, userData) => {
    const response = await fetch(`${BASE_URL}${domain}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${userToken}`  
        },
        body: JSON.stringify(userData)
    });

    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
};
----